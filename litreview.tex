% DefCrypt main.tex
% Started 4/2/2017

\documentclass[11pt,twoside]{article}

% ==================================================================
% Subfile Package/Commands
% ==================================================================

\usepackage{subfiles,algorithm2e}

\newcommand{\onlyinsubfile}[1]{#1}
\newcommand{\notinsubfile}[1]{}

\makeatletter
\def\input@path{{./}{../../}}
\makeatother

% ==================================================================
% Crypto Packages
% ==================================================================

\usepackage{defcrypt}
\usepackage{cryptocode}


% ==================================================================
% Document
% ==================================================================

\begin{document}
    \renewcommand{\onlyinsubfile}[1]{}
    \renewcommand{\notinsubfile}[1]{#1}
  
\section{Rivest (1997)}

\subsection{Original Definition}

The original definition of Rivest looks like this: 

Consider a function $f$ that takes the message sequence $m_1,m_2\dots m_s$ and returns pseudo-message sequence $m'_1,m'_2\dots m'_{s'}$. We call $f$ an AONT when the following are satisfied: 

\begin{itemize}

\item The transformation $f$ is reversible: Given the pseudo-message sequence, one can obtain the original message sequence. 
\item Both $f$ and its inverse are efficiently computable (PT) 
\item It is computationally infeasible to compute any function of any message block if any one of the pseudo-message blocks is unknown. 

\end{itemize} 

\subsection{Formalized Definition}

This is my attempt to formalize this definition with concrete security games. 

\emph{Note that because we are talking in concrete security, I make no comment on efficiency of any of the algorithms} 

An \emph{All-Or-Nothing-Transform} $\schemefont{AONT}$ specifies two algorithms $(\schemefont{AONT.Transform}, \schemefont{AONT.Inverse})$, and a block length $\schemefont{AONT.bl}$. We have that $\schemefont{AONT.Transform}: \{ \bits^\schemefont{AONT.bl}\}^*\rightarrow \{ \bits^\schemefont{AONT.bl}\}^*$. We call the domain of this function ``message sequences'' and the range ``pseudo-message sequences''. Then $\schemefont{AONT.Inverse}$ is the inverse of this function, meaning that $\schemefont{AONT.Inverse}: \{ \bits^\schemefont{AONT.bl}\}^*\rightarrow \{ \bits^\schemefont{AONT.bl}\}^*$, a mapping that only needs to be defined on pseudo-message sequences that can be generated by $\schemefont{AONT.Transform}$. $\schemefont{AONT.Transform}$ can (and should) be randomized, while $\schemefont{AONT.Inverse}$ is not randomized.

The correctness condition for $\schemefont{AONT}$ is $$\Prob{\schemefont{AONT.Inverse}(\schemefont{AONT.Transform}((m_1,m_2\dots m_s))=(m_1,m_2,\dots m_s))} = 1$$ where the probability is taken over all possible message sequences $(m_1,m_2\dots m_s)$ and all possible randomness of the $\schemefont{AONT.Transform}$ function. 

Now we can define the following security game:

\pagebreak
\begin{figure}[h]
\oneCol{0.5}
{
\underline{$\gamefont{G}_{\schemefont{AONT}}^\text{ind}(\advA)$}

\begin{algorithm}[H]
$b \getsr \bits$\\
$b' \getsr \advA^{\LRO}$\\
\Return $(b=b')$
\end{algorithm}

\smallskip
\underline{$\LRO(m^*,n^*,i,j)$}

\begin{algorithm}[H]
\If{$(\len{m^*}\neq \schemefont{AONT.bl})\lor (\len{n^*}\neq \schemefont{AONT.bl})\lor(i>j)$}
{
\Return $\bot$
}
\For{$(x=1,2,\dots j)$}
{
\eIf{$(x\neq i)$}
{
$m_x \getsr \bits^\schemefont{AONT.bl}$\\
$n_x \getsr \bits^\schemefont{AONT.bl}$\\

}
{
$m_x\gets m^*$\\
$n_x\gets n^*$
}
}
\eIf{$b=0$}{
$y\getsr \schemefont{AONT.Transform}(m_1,m_2\dots m_s)$\\
}{
$y\getsr \schemefont{AONT.Transform}(n_1,n_2\dots n_s)$\\
}
\Return $y$
\end{algorithm}
}
\end{figure}


Then we say that the AONT indistinguishability advantage of an $\advA$ is given by: 

$$\textbf{Adv}^\text{aont}_\schemefont{AONT}(\advA)=2\cdot\Prob{\gamefont{G}_{\schemefont{AONT}}^\text{ind}(\advA)} - 1$$

\subsection{Package Transform}

Rivest provides a construction of an AONT proceeding as follows. It makes use of an arbitrary block cipher, with key of length $\schemefont{AONT.bl}$, $E : \bits^\schemefont{AONT.bl} \times \bits^\schemefont{AONT.bl}\rightarrow \schemefont{AONT.bl}$. I edited this a bit for clarity (with respect to the keys). 
%I added details and a padding function $\schemefont{pad}_b$ which takes a binary string and pads it to a length that is a multiple of $b$, and inverse of this padding function $\schemefont{unpad}_b$. We also write $\langle i \rangle_b$ for the $b$-bit binary representation of integer $i$.

\begin{figure}[h]
\twoCols{0.5}{0.5}
{
\underline{$\schemefont{AONT.Transform}(m_1,m_2,\dots m_s)$}

\begin{algorithm}[H]
\If{$\exists i.\len{m_i}\neq\schemefont{AONT.bl}$}{\Return $\bot$}
$K\getsr \bits^\schemefont{AONT.bl}$\\
$K'\getsr \bits^\schemefont{AONT.bl}$\\
$m'_{s+1}\gets K'$\\
\For{$i=1,2\dots s$}
{
$m'_i\gets m_i \oplus E(K',\langle i \rangle_\schemefont{AONT.bl})$\\
$h_i\gets E(K,m'_i\oplus \langle i \rangle_\schemefont{AONT.bl})$\\
$m'_{s+1}\gets m'_{s+1}\oplus h_i$\\
}
\Return $(m'_1,m'_2\dots m'_s, m'_{s+1}, K)$
\end{algorithm}
}
{
\underline{$\schemefont{AONT.Inverse}(m'_1,m'_2\dots m'_{s'})$}

\begin{algorithm}[H]
\If{$(\exists i.\len{m'_i}\neq\schemefont{AONT.bl})\lor (s' \le 2)$}{\Return $\bot$}
$K\gets m'_{s'}$\\
$K'\gets m'_{s'-1}$\\
$s\gets s'-2$\\
\For{$(i=1,2,\dots s)$}
{
$h_i\gets E(K,m'_i\oplus i)$\\
$K'\gets K'\oplus h_i$
}
\For{$(i=1,2,\dots s)$}
{
$m_i\gets E(K',i)\oplus m'_i$\\
}
\Return $(m_1,m_2\dots m_{s})$
\end{algorithm}
}
\end{figure} 
No proof is provided as to the security of this scheme. The phrasing of the ``informal'' proof also seems problematic because it talks about an adversary that is attempting to ``compute any message block'' instead of any function of any message block, which is not the same as was suggested by the definition.

\pagebreak 

\section{Boyko (1999)}

\subsection{Overview and Important Notes} 

Boyko presents the first formal security notion for AONTs, making some changes to the one implied by Rivest. Some of these choices are justified, and some seem less so. 

He proposes notions of secuirty based on both adaptive and non-adaptive models, and both semantic security and indistinguishability based definitions. He doesn't explain why there is a need for so many of these, and which ones imply which ones. I think this is interesting and worth looking at. 

Finally, the key contribution of this paper (in my opinion) is showing that OAEP is usable in the package transform proposed by Rivest in order to achieve an AONT. With all of the above in mind, I would like to show explicitly that this construction still provides the security guarantees that Boyko claims, under the security definition of Rivest (which is quoted much more often in literature). 

\subsection{Commentary on Boyko's critique of Rivest (1997)}

Boyko lists two major ``problems'' with the Rivest definition. To me, while the Rivest definition was not explicitly spelt out in a security game, is intuitive and plenty sufficient to discuss AONTs. Especially since many application papers (like all those I study), use the Rivest definition, there are clear benefits to try to show the rest of Boyko's claims using the Rivest definition. 

The first of Boyko's claims is that we would want our AONT to be secure against an adversary that is trying to compute some information about the message as a whole, instead of an adversary that is trying to compute some information about one particular message block. Since the former adversary is more general, Boyko claims it would make for a better definition. Note that the analogous definition suggested by this comment of Boyko's would allow the adversary to pick the entire message instead of picking just one block of the message in the game $\gamefont{G}_{\schemefont{AONT}}^\text{ind}$ above. The oracle suggested by Boyko will just skip over the random generation of the other blocks done by $\LRO$ above, and proceed similarly. Then, consider any adversary $A$ against $\gamefont{G}_{\schemefont{AONT}}^\text{ind}$ as defined by Rivest. Notice that we can trivially generate adversary $A'$ against the analogous game suggested by Boyko's comment here. $A'$ will simply take any pair of blocks queried by $A$ and randomly generate the remaining blocks, before passing it to the Boyko oracle analogous to $\LRO$. Therefore, if we have an attack against Rivest's model, we have an attack against Boyko's model. This means that if a scheme is an AONT by Boyko's model, it is also an AONT by Rivest's model. This shows that Boyko's claim is true. 

More informally (this was contributed by Igors) an adversary may be able to compute a function about the message has a whole without knowing anything about any particular block (e.g. if the first block is equal to the second block). Therefore, Boyko's definition is stronger. 

The second of Boyko's claims is that Rivest's definition does not allow for analysis of the relation between the number of bits of AONT output that the adversary has and the information that is leaked about the input. I find this comment very strange since the whole point of AONTs is that no matter how many bits of information is given to the adversary, so long as there is one block that is not accessible to the adversary, it is still computationally infeasible for the adversary to predict any information about the message sequence better than if he randomly guesses. Boyko's paper suggests that instead of stipulating that there must exist a block that the adversary knows nothing about, that we should consider what the adversary's advantage is with respect to the number of bits that were not leaked. This means studying the advantage of adversaries for varying values of $l$, where the adversary is given all but $l$ bits of the pseudo-message. 

Both of these comments are definitely valid. I believe that Rivest's definition considers the cryptanalysis of AONT in a more traditional sense, where the encrypted data is being stored as blocks, or being communicated over a secure channel as blocks. The adversary would then capture or steal entire blocks of the pseudomessage. However, Boyko's definition encompasses more current forms of cryptanalysis, such as side channel attacks, which may leak partial blocks of data. However, since most papers studying constructions and applications of AONT do make use of Rivest's definition, I think there is value in using Rivest's definition as the standard. In addition, I think that intuitively an ``all-or-nothing-transform'' should have the security properties suggested by Rivest even if the message sequence and pseudomessage sequence is permuted. In fact, I think that we can show that: 

\begin{definition}
We call a scheme $\schemefont{AONT}$ a strong-AONT if, for all $f:\{\bits^\schemefont{AONT.bl}\}\rightarrow\{\bits^\schemefont{AONT.bl}\}$ that define permutations on strings, $(f\circ\schemefont{AONT.Transform},\schemefont{AONT.Inverse}\circ f^{-1})$ is an AONT by Rivest's definition. 
\end{definition}

I conjecture that the following is true

\begin{theorem}
A scheme is secure with respect to Boyko's definition (adaptive indistinguishability), for any leakage up to $\schemefont{AONT.bl}$ bits if and only if it is a strong-AONT
\end{theorem}

This shows some equivalence between the two definitions.

\subsection{Other comments} 

I don't understand why Boyko feels the need to include both indistinguishability and simulation based security definitions. I think that we can prove which one is a stronger claim and move forward with a limited subset of these. 

Boyko does present an important result which is to use OAEP in the design of the package transform algorithm. I would like to give an explicit proof (without making use of Boyko's definition) that this still works with Rivest's definition. 
\appendix

\end{document}
