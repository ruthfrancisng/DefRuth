% DefCrypt main.tex
% Started 4/2/2017

\documentclass[11pt,twoside]{article}

% ==================================================================
% Subfile Package/Commands
% ==================================================================

\usepackage{subfiles,algorithm2e}

\newcommand{\onlyinsubfile}[1]{#1}
\newcommand{\notinsubfile}[1]{}

\makeatletter
\def\input@path{{./}{../../}}
\makeatother

% ==================================================================
% Crypto Packages
% ==================================================================

\usepackage{defcrypt}
\usepackage{cryptocode}


% ==================================================================
% Document
% ==================================================================

\begin{document}
    \renewcommand{\onlyinsubfile}[1]{}
    \renewcommand{\notinsubfile}[1]{#1}
  
\section{Rivest (1997)}

\subsection{Original Definition}

The original definition of Rivest looks like this: 

Consider a function $f$ that takes the message sequence $m_1,m_2\dots m_s$ and returns pseudo-message sequence $m'_1,m'_2\dots m'_{s'}$. We call $f$ an AONT when the following are satisfied: 

\begin{itemize}

\item The transformation $f$ is reversible: Given the pseudo-message sequence, one can obtain the original message sequence. 
\item Both $f$ and its inverse are efficiently computable (PT) 
\item It is computationally infeasible to compute any function of any message block if any one of the pseudo-message blocks is unknown. 

\end{itemize} 

\subsection{Formalized Definition}

This is my attempt to formalize this definition with concrete security games. 

\emph{Note that because we are talking in concrete security, I make no comment on efficiency of any of the algorithms} 

An \emph{All-Or-Nothing-Transform} $\schemefont{AONT}$ specifies two algorithms $(\schemefont{AONT.Transform}, \schemefont{AONT.Inverse})$, and a block length $\schemefont{AONT.bl}$. We have that $\schemefont{AONT.Transform}: \{ \bits^\schemefont{AONT.bl}\}^*\rightarrow \{ \bits^\schemefont{AONT.bl}\}^*$. We call the domain of this function ``message sequences'' and the range ``pseudo-message sequences''. Then $\schemefont{AONT.Inverse}$ is the inverse of this function, meaning that $\schemefont{AONT.Inverse}: \{ \bits^\schemefont{AONT.bl}\}^*\rightarrow \{ \bits^\schemefont{AONT.bl}\}^*$, a mapping that only needs to be defined on pseudo-message sequences that can be generated by $\schemefont{AONT.Transform}$. $\schemefont{AONT.Transform}$ can (and should) be randomized, while $\schemefont{AONT.Inverse}$ is not randomized.

The correctness condition for $\schemefont{AONT}$ is $$\Prob{\schemefont{AONT.Inverse}(\schemefont{AONT.Transform}((m_1,m_2\dots m_s))=(m_1,m_2,\dots m_s))} = 1$$ where the probability is taken over all possible message sequences $(m_1,m_2\dots m_s)$ and all possible randomness of the $\schemefont{AONT.Transform}$ function. 

Now we can define the following security game:

\begin{figure}[h]
\oneCol{0.5}
{
\underline{$\gamefont{G}_{\schemefont{AONT}}^\text{aont}(\advA)$}

\begin{algorithm}[H]
$b \getsr \bits$\\
$b' \getsr \advA^{\LRO}$\\
\Return $(b=b')$
\end{algorithm}

\smallskip
\underline{$\LRO(m^*,n^*,i,j)$}

\begin{algorithm}[H]
\If{$(\len{m^*}\neq \schemefont{AONT.bl})\lor (\len{n^*}\neq \schemefont{AONT.bl})\lor(i>j)$}
{
\Return $\bot$
}
\For{$(x=1,2,\dots j)$}
{
\eIf{$(x\neq i)$}
{
$m_x \getsr \bits^\schemefont{AONT.bl}$\\
$n_x \getsr \bits^\schemefont{AONT.bl}$\\

}
{
$m_x\gets m^*$\\
$n_x\gets n^*$
}
}
\eIf{$b=0$}{
$y\getsr \schemefont{AONT.Transform}(m_1,m_2\dots m_s)$\\
}{
$y\getsr \schemefont{AONT.Transform}(n_1,n_2\dots n_s)$\\
}
\Return $y$
\end{algorithm}
}
\end{figure}

\pagebreak

Then we say that the AONT indistinguishability advantage of an $\advA$ is given by: 

$$\textbf{Adv}^\text{aont}_\schemefont{AONT}(\advA)=2\cdot\Prob{\gamefont{G}_{\schemefont{AONT}}^\text{aont}(\advA)} - 1$$

\subsection{Package Transform}

Rivest provides a construction of an AONT proceeding as follows. It makes use of an arbitrary block cipher, with key of length $\schemefont{AONT.bl}$, $E : \bits^\schemefont{AONT.bl} \times \bits^\schemefont{AONT.bl}\rightarrow \schemefont{AONT.bl}$. I edited this a bit for clarity (with respect to the keys). 
%I added details and a padding function $\schemefont{pad}_b$ which takes a binary string and pads it to a length that is a multiple of $b$, and inverse of this padding function $\schemefont{unpad}_b$. We also write $\langle i \rangle_b$ for the $b$-bit binary representation of integer $i$.

\begin{figure}[h]
\twoCols{0.5}{0.5}
{
\underline{$\schemefont{AONT.Transform}(m_1,m_2,\dots m_s)$}

\begin{algorithm}[H]
\If{$\exists i.\len{m_i}\neq\schemefont{AONT.bl}$}{\Return $\bot$}
$K\getsr \bits^\schemefont{AONT.bl}$\\
$K'\getsr \bits^\schemefont{AONT.bl}$\\
$m'_{s+1}\gets K'$\\
\For{$i=1,2\dots s$}
{
$m'_i\gets m_i \oplus E(K',\langle i \rangle_\schemefont{AONT.bl})$\\
$h_i\gets E(K,m'_i\oplus \langle i \rangle_\schemefont{AONT.bl})$\\
$m'_{s+1}\gets m'_{s+1}\oplus h_i$\\
}
\Return $(m'_1,m'_2\dots m'_s, m'_{s+1}, K)$
\end{algorithm}
}
{
\underline{$\schemefont{AONT.Inverse}(m'_1,m'_2\dots m'_{s'})$}

\begin{algorithm}[H]
\If{$(\exists i.\len{m'_i}\neq\schemefont{AONT.bl})\lor (s' \le 2)$}{\Return $\bot$}
$K\gets m'_{s'}$\\
$K'\gets m'_{s'-1}$\\
$s\gets s'-2$\\
\For{$(i=1,2,\dots s)$}
{
$h_i\gets E(K,m'_i\oplus i)$\\
$K'\gets K'\oplus h_i$
}
\For{$(i=1,2,\dots s)$}
{
$m_i\gets E(K',i)\oplus m'_i$\\
}
\Return $(m_1,m_2\dots m_{s})$
\end{algorithm}
}
\end{figure} 
\pagebreak
No proof is provided as to the security of this scheme. The phrasing of the ``informal'' proof also seems problematic because it talks about an adversary that is attempting to ``compute any message block'' instead of any function of any message block, which is not the same as was suggested by the definition.

\appendix

\end{document}
