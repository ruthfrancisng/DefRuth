% DefCrypt main.tex
% Started 4/2/2017

\documentclass[11pt,twoside]{article}

% ==================================================================
% Subfile Package/Commands
% ==================================================================

\usepackage{subfiles,algorithm2e}

\newcommand{\onlyinsubfile}[1]{#1}
\newcommand{\notinsubfile}[1]{}

\makeatletter
\def\input@path{{./}{../../}}
\makeatother

% ==================================================================
% Crypto Packages
% ==================================================================

\usepackage{defcrypt}
\usepackage{cryptocode}


% ==================================================================
% Document
% ==================================================================

\begin{document}
    \renewcommand{\onlyinsubfile}[1]{}
    \renewcommand{\notinsubfile}[1]{#1}
  
\section{Syntax}

[BLMR]'s proposed syntax involves a tuple $$\mathsf{UpEnc = (UpEnc.KeyGen, UpEnc.Enc, UpEnc.Dec, UpEnc.ReKeyGen,UpEnc.ReEnc)}$$, where $\mathsf{UpEnc.ReKeyGen}$ takes two keys (generated by $\mathsf{UpEnc.KeyGen}$) and generates a constant size ``rekeying token'', which will be passed into $\mathsf{UpEnc.ReEnc}$ together with the ciphertext encrypted under the first key, which will in turn output the ciphertext encrypted under the other key. 

I don't think that this is necessary. I propose a syntax of the form $$\mathsf{UpEnc = (UpEnc.KeyGen, UpEnc.Enc, UpEnc.Dec, UpEnc.ReEnc)}$$, where $\mathsf{UpEnc.ReEnc}$ instead takes the two keys and the ciphertext. I argue the reason behind this in a separate report. 

We can define the specific syntax for the tuple of algorithms we propose

\begin{enumerate}
\item $KeyGen:\{\epsilon\}\rightarrow\bits^k$, a key generation algorithm returning a $k$ bit long key, this should be randomized. 
\item $Enc:\bits^k\times\bits^*\rightarrow\bits^*$, an encryption algorithm that takes a key and a string and returns a string, this should be randomized. 
\item $Dec:\bits^k\times \bits^*\rightarrow\bits^*$, a decryption algorithm that takes a key and a string and returns a string, this should not be randomized.
\item $ReEnc:\bits^k\times\bits^k\times\bits^*\rightarrow\bits^*$, an encryption algorithm that takes an old key, a new key, an encryption of a string under the old key and returns an encryption of the string under the new key. This should be randomized. 
\end{enumerate} 

\section{Correctness}
This is the correctness condition 

\begin{figure}[H]
\twoCols{0.5}{0.5}
{
\underline{$\gamefont{G}_{\mathsf{UpEnc},A}^\text{corr}$}

\begin{algorithm}[H]
$i\gets 0$\\
$j\gets 0$\\
$j^*\getsr A^{\procfont{Set,KeyGen,Enc}}()$\\
$(M,C,k)\gets M_{j^*}$\\
\If{$k=\epsilon$}{\Return \texttt{false}}
$M'\gets \mathsf{UpEnc.Dec}(C,K_k)$\\
\Return $(M'=M)$
\end{algorithm}


\underline{$\procfont{KeyGen}()$}

\begin{algorithm}[H]
$K_i\getsr \mathsf{UpEnc.KeyGen}$\\
$i\gets i+1$\\
\Return $K_i$
\end{algorithm}
}
{

\underline{$\procfont{Set}(M)$}

\begin{algorithm}[H]
$M_i\gets (M,\epsilon,\epsilon)$\\
$j\gets j+1$\\
\end{algorithm}

\underline{$\procfont{Enc}(i',j')$}

\begin{algorithm}[H]
\If{$(j'>j)\lor(i'>i)$}{\Return $\bot$}
$(M,C,k)\gets M_{j'}$\\
\eIf{$k=\epsilon$}{$C\getsr \mathsf{UpEnc.Enc(K_{i'},M)}$}{$C\getsr \mathsf{UpEnc.ReEnc}(K_k,K_{i'},C)$}
$M_{j'}\gets (M,C,i')$\\
\Return $C$
\end{algorithm}
}
\end{figure} 

Then, we can say that $\mathsf{UpEnc}$ satisfies the correctness condition if, for all adversaries $A$ we have that: 
$$\Pr [\gamefont{G}_{\mathsf{UpEnc},A}^\text{corr}]=0$$


\section{Rivest (1997)}

\begin{figure}[H]
\oneCol{0.5}
{
\underline{$\gamefont{G}_{\mathsf{AONT}}^\text{ind}(\advA)$}

\begin{algorithm}[H]
$b \getsr \bits$\\
$b' \getsr \advA^{\LRO}$\\
\Return $(b=b')$
\end{algorithm}

\smallskip
\underline{$\LRO(M,N,i)$}

\begin{algorithm}[H]
\If{$|M|\neq|N|$}{\Return $\bot$}  
$(m_1,m_2\dots m_s)\gets M$\\
$(n_1,n_2\dots n_s)\gets N$\\
$n_i\gets \epsilon$\\
$m_i\gets \epsilon$\\
\eIf{$b=0$}{
$y\getsr \mathsf{AONT.Transform}(m_1,m_2\dots m_s)$\\
}{
$y\getsr \mathsf{AONT.Transform}(n_1,n_2\dots n_s)$\\
}
\Return $y$
\end{algorithm}
}
\end{figure}

Then we say that the indistinguishability adversary $\advA$ has $l$-AONT-IND advantage: 

$$\textbf{Adv}^\text{aont-ind}_\mathsf{AONT}(\advA)=2\cdot\Prob{\gamefont{G}_{\mathsf{AONT}}^\text{ind}(\advA)} - 1$$

\section{Boyko (1999)/ Canetti et. al (2000)}

\begin{figure}[H]
\oneCol{0.5}
{
\underline{$\gamefont{G}_{\mathsf{AONT},l}^\text{leak}(\advA)$}

\begin{algorithm}[H]
$b \getsr \bits$\\
$b' \getsr \advA^{\LRO}$\\
\Return $(b=b')$
\end{algorithm}

\smallskip
\underline{$\LRO(M,N,S)$}

\begin{algorithm}[H]
\If{$|M|\neq|N|$}{\Return $\bot$}  
$(m_1,m_2\dots m_s)\gets M$\\
$(n_1,n_2\dots n_s)\gets N$\\
\eIf{$b=0$}{
$y\getsr \mathsf{AONT.Transform}(m_1,m_2\dots m_s)$\\
}{
$y\getsr \mathsf{AONT.Transform}(n_1,n_2\dots n_s)$\\
}
\eIf{$(|S|\neq|y|)\lor(\mathsf{Hamm}(S)>(|y| - l))$}{\Return $\bot$}{$y\gets y\mathrel{\&} S$}
\Return $y$
\end{algorithm}
}
\end{figure}

\emph{Note that $|M|$ is the length of the string $M$ in bits, $\mathrel{\&}$ is a bitwise AND and $\mathsf{Hamm}(M)$ takes the hamming weight of $M$}

Then we say that the leakage adversary $\advA$ has $l$-AONT-LEAK advantage: 

$$\textbf{Adv}^\text{aont-leak}_{\mathsf{AONT},l}(\advA)=2\cdot\Prob{\gamefont{G}_{\mathsf{AONT},l}^\text{leak}(\advA)} - 1$$

\section{Leakage Resilience Model} 

\begin{figure}[H]
\oneCol{0.5}
{
\underline{$\gamefont{G}_{\mathsf{AONT},m}^\text{lr}(\advA)$}

\begin{algorithm}[H]
$b \getsr \bits$\\
$b' \getsr \advA^{\LRO}$\\
\Return $(b=b')$
\end{algorithm}

\smallskip
\underline{$\LRO(M,N,C)$}

\begin{algorithm}[H]
\If{$|M|\neq|N|$}{\Return $\bot$}  
$(m_1,m_2\dots m_s)\gets M$\\
$(n_1,n_2\dots n_s)\gets N$\\
\eIf{$b=0$}{
$y\getsr \mathsf{AONT.Transform}(m_1,m_2\dots m_s)$\\
}{
$y\getsr \mathsf{AONT.Transform}(n_1,n_2\dots n_s)$\\
}
\eIf{$(C\notin\mathcal{C}_{|y|,(|y| - m)})$}{\Return $\bot$}{\Return $C(y)$}
\end{algorithm}
}
\end{figure}

\emph{Note that $\mathcal{C}_{n,m}$ is the set of boolean circuits taking $n$ inputs and $m$ outputs, expressed in a string in some reasonable encoding. Then, for $C\in \mathcal{C}_{n,m}$, when we run $C(S)$ for some binary string $S$ of length $n$, $C$ will take as input the bits of $S$ and return a $m$ bit long string.}

Then we say that the leakage resilience adversary $\advA$ has $m$-AONT-LR advantage: 

$$\textbf{Adv}^\text{aont-lr}_{\mathsf{AONT},m}(\advA)=2\cdot\Prob{\gamefont{G}_{\mathsf{AONT},m}^\text{lr}(\advA)} - 1$$

\section{Relationship between Notions} 

\subsection{$\mathsf{AONT.bl}$-AONT-L$\implies$AONT-IND}

\begin{theorem}
For any AONT-IND adversary $\advA$, we can construct $\mathsf{AONT.bl}$-AONT-L adversary $\advB$, running in the same time and making the same number of queries, such that $$\textbf{Adv}^\text{aont-ind}_{\mathsf{AONT}}(\advA)\le\textbf{Adv}^\text{aont-leak}_{\mathsf{AONT},\mathsf{AONT.bl}}(\advB)$$
\end{theorem}

Here is the adversary (the full proof is omitted for now):

\begin{figure}[H]
\oneCol{0.5}
{
\underline{$\advB^\LRO$}

\begin{algorithm}[H]
$b\getsr \advA^{\procfont{SimLR}}$\\
\Return $b$
\end{algorithm}

\underline{$\procfont{SimLR}(M,N,i)$}

\begin{algorithm}[H]
$mask\gets \epsilon$\\
$s\gets \lceil\frac{|M|}{\mathsf{AONT.bl}}\rceil$\\
\For{$j=1,2,\dots s$}
{
\eIf{$j\neq i$}{$mask\gets mask||1^\mathsf{AONT.bl}$}{$mask\gets mask||0^\mathsf{AONT.bl}$}}
\Return $\LRO(M,N,mask)$
\end{algorithm}
}
\end{figure}

\subsection{$l$-AONT-L$\implies$ $l$-AONT-LR}

\begin{theorem}
For any $l$-AONT-L adversary $\advA$, we can construct $l$-AONT-LR adversary $\advB$, running in the same time and making the same number of queries, such that $$\textbf{Adv}^\text{aont-leak}_{\mathsf{AONT},l}(\advA)\le\textbf{Adv}^\text{aont-lr}_{\mathsf{AONT},l}(\advB)$$
\end{theorem}

Here is the adversary (the full proof is omitted for now):

\begin{figure}[H]
\oneCol{0.5}
{
\underline{$\advB^\LRO$}

\begin{algorithm}[H]
$b\getsr \advA^{\procfont{SimLR}}$\\
\Return $b$
\end{algorithm}

\underline{$\procfont{SimLR}(M,N,mask)$}

\begin{algorithm}[H]
\Return $\LRO(M,N,C_{mask})$
\end{algorithm}

\underline{$C_{mask}(X)$}

\begin{algorithm}[H]
\Return $mask \mathrel{\&} X$
\end{algorithm}
}
\end{figure}

\subsection{AONT-IND $\not\Rightarrow \mathsf{AONT.bl}$-AONT-L}

For simplicity, we will use a trivial AONT to illustrate this, though this can also be done similarly with the ``package transform'' and other more practical AONTs. Consider the following AONT, $\mathsf{XOR-AONT}$ with some sufficiently large block length to prevent exhaustive searches (e.g. 256 bits)

\begin{figure}[h]
\oneCol{0.8}
{
\underline{$\schemefont{XOR-AONT.Transform}(m_1,m_2,\dots m_s)$}

\begin{algorithm}[H]
\For{$i=1,2\dots s$}
{
\For{$j=1,2\dots \mathsf{XOR-AONT.bl}-1$}
{
$n_{i,j}\getsr\bits^{\mathsf{XOR-AONT.bl}}$
}
$n_{i,\mathsf{XOR-AONT.bl}}\getsr m_i \oplus n_{i,1} \oplus n_{i,2} \dots \oplus n_{i,\mathsf{XOR-AONT.bl}}$
}
\Return $(n_{1,1},n_{1,2}\dots n_{1,\mathsf{XOR-AONT.bl}},n_{2,1},n_{2,2}\dots n_{s,\mathsf{XOR-AONT.bl}})$
\end{algorithm}

\underline{$\schemefont{XOR-AONT.Inverse}(m'_1,m'_2\dots m'_{s'})$}

\begin{algorithm}[H]
$(n_{1,1},n_{1,2}\dots n_{1,\mathsf{XOR-AONT.bl}},n_{2,1},n_{2,2}\dots n_{s,\mathsf{XOR-AONT.bl}})\gets (m'_1,m'_2\dots m'_{s'})$\\
\For{$i=1,2,\dots s$}
{
$m_i\gets n_{i,1}\oplus n_{i,2}\oplus \dots \oplus n_{i,\mathsf{XOR-AONT.bl}}$
}
\Return $(m_1,m_2\dots m_s)$
\end{algorithm}
}
\end{figure} 

Then, we modify this to the following, with the same block length: 

\begin{figure}[h]
\oneCol{0.8}
{
\underline{$\schemefont{MOD-XOR-AONT.Transform}(m_1,m_2,\dots m_s)$}

\begin{algorithm}[H]
\For{$i=1,2\dots s$}
{
\For{$j=1,2\dots \mathsf{MOD-XOR-AONT.bl}-1$}
{
$n_{i,j}\getsr\bits^{\mathsf{MOD-XOR-AONT.bl}}$
}
$n_{i,\mathsf{MOD-XOR-AONT.bl}}\getsr m_i \oplus n_{i,1} \oplus n_{i,2} \dots \oplus n_{i,\mathsf{MOD-XOR-AONT.bl}}$
}
$(m'_1,m'_2,\dots m'_{s'})  \gets (n_{1,1},n_{1,2}\dots n_{1,\mathsf{MOD-XOR-AONT.bl}},n_{2,1},n_{2,2}\dots n_{s,\mathsf{MOD-XOR-AONT.bl}})$\\
\For{$i=1,2\dots \mathsf{MOD-XOR-AONT.bl}$}
{
$b_i\gets m'_i \mathrel{\&} (0^{\mathsf{MOD-XOR-AONT.bl}-1}1)$\\
$m'_i\gets m'_i \mathrel{\&} (1^{\mathsf{MOD-XOR-AONT.bl}-1}0)$\\
}
$m'_0\gets b_1||b_2\dots b_\mathsf{MOD-XOR-AONT.bl}$\\
\Return $(m'_0,m'_1,m'_2,\dots m'_{s'})$
\end{algorithm}

\underline{$\schemefont{MOD-XOR-AONT.Inverse}(m'_0,m'_1\dots m'_{s'})$}

\begin{algorithm}[H]
$b_1||b_2\dots b_\mathsf{MOD-XOR-AONT.bl}\gets m'_0$\\
\For{$i=1,2\dots \mathsf{MOD-XOR-AONT.bl}$}
{
$b_i\gets b_i \mathrel{\&} (0^{\mathsf{MOD-XOR-AONT.bl}-1}1)$\\
$m'_i\gets m'_i \oplus b_i$\\
}
$(n_{1,1},n_{1,2}\dots n_{1,\mathsf{MOD-XOR-AONT.bl}},n_{2,1},n_{2,2}\dots n_{s,\mathsf{MOD-XOR-AONT.bl}})\gets (m'_1,m'_2\dots m'_{s'})$\\
\For{$i=1,2,\dots s$}
{
$m_i\gets n_{i,1}\oplus n_{i,2}\oplus \dots \oplus n_{i,\mathsf{XOR-AONT.bl}}$
}
\Return $(m_1,m_2\dots m_s)$
\end{algorithm}
}
\end{figure} 


PACKAGE TRANSFORM IS NOT LEAKAGE RESISTANT
\end{document}
