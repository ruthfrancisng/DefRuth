% DefCrypt main.tex
% Started 4/2/2017

\documentclass[11pt,twoside]{article}

% ==================================================================
% Subfile Package/Commands
% ==================================================================

\usepackage{subfiles,algorithm2e}

\newcommand{\onlyinsubfile}[1]{#1}
\newcommand{\notinsubfile}[1]{}

\makeatletter
\def\input@path{{./}{../../}}
\makeatother

% ==================================================================
% Crypto Packages
% ==================================================================

\usepackage{defcrypt}
\usepackage{cryptocode}


% ==================================================================
% Document
% ==================================================================

\begin{document}
    \renewcommand{\onlyinsubfile}[1]{}
    \renewcommand{\notinsubfile}[1]{#1}
  
\section{Syntax}

[BLMR]'s proposed syntax involves a tuple $$\mathsf{UpEnc = (UpEnc.KeyGen, UpEnc.Enc, UpEnc.Dec, UpEnc.ReKeyGen,UpEnc.ReEnc)}$$, where $\mathsf{UpEnc.ReKeyGen}$ takes two keys (generated by $\mathsf{UpEnc.KeyGen}$) and generates a constant size ``rekeying token'', which will be passed into $\mathsf{UpEnc.ReEnc}$ together with the ciphertext encrypted under the first key, which will in turn output the ciphertext encrypted under the other key. 

I don't think that this is necessary. I propose a syntax of the form $$\mathsf{UpEnc = (UpEnc.KeyGen, UpEnc.Enc, UpEnc.Dec, UpEnc.ReEnc)}$$, where $\mathsf{UpEnc.ReEnc}$ instead takes the two keys and the ciphertext. I argue the reason behind this in a separate report. 

We can define the specific syntax for the tuple of algorithms we propose

\begin{enumerate}
\item $KeyGen:\{\epsilon\}\rightarrow\bits^k$, a key generation algorithm returning a $k$ bit long key, this should be randomized. 
\item $Enc:\bits^k\times\bits^*\rightarrow\bits^*$, an encryption algorithm that takes a key and a string and returns a string, this should be randomized. 
\item $Dec:\bits^k\times \bits^*\rightarrow\bits^*$, a decryption algorithm that takes a key and a string and returns a string, this should not be randomized.
\item $ReEnc:\bits^k\times\bits^k\times\bits^*\rightarrow\bits^*$, an encryption algorithm that takes an old key, a new key, an encryption of a string under the old key and returns an encryption of the string under the new key. This should be randomized. 
\end{enumerate} 

\section{Correctness}
This is the correctness condition 

\begin{figure}[H]
\twoCols{0.5}{0.5}
{
\underline{$\gamefont{G}_{\mathsf{UpEnc},A}^\text{corr}$}

\begin{algorithm}[H]
$i\gets 0$\\
$j\gets 0$\\
$j^*\getsr A^{\procfont{Set,KeyGen,Enc}}()$\\
$(M,C,k)\gets M_{j^*}$\\
\If{$k=\epsilon$}{\Return \texttt{false}}
$M'\gets \mathsf{UpEnc.Dec}(C,K_k)$\\
\Return $(M'=M)$
\end{algorithm}


\underline{$\procfont{KeyGen}()$}

\begin{algorithm}[H]
$K_i\getsr \mathsf{UpEnc.KeyGen}$\\
$i\gets i+1$\\
\Return $K_i$
\end{algorithm}
}
{

\underline{$\procfont{Set}(M)$}

\begin{algorithm}[H]
$M_i\gets (M,\epsilon,\epsilon)$\\
$j\gets j+1$\\
\end{algorithm}

\underline{$\procfont{Enc}(i',j')$}

\begin{algorithm}[H]
\If{$(j'>j)\lor(i'>i)$}{\Return $\bot$}
$(M,C,k)\gets M_{j'}$\\
\eIf{$k=\epsilon$}{$C\getsr \mathsf{UpEnc.Enc(K_{i'},M)}$}{$C\getsr \mathsf{UpEnc.ReEnc}(K_k,K_{i'},C)$}
$M_{j'}\gets (M,C,i')$\\
\Return $C$
\end{algorithm}
}
\end{figure} 

Then, we can say that $\mathsf{UpEnc}$ satisfies the correctness condition if, for all adversaries $A$ we have that: 
$$\Pr [\gamefont{G}_{\mathsf{UpEnc},A}^\text{corr}]=0$$


\section{Rivest (1997)}

\begin{figure}[H]
\oneCol{0.5}
{
\underline{$\gamefont{G}_{\mathsf{AONT}}^\text{ind}(\advA)$}

\begin{algorithm}[H]
$b \getsr \bits$\\
$b' \getsr \advA^{\LRO}$\\
\Return $(b=b')$
\end{algorithm}

\smallskip
\underline{$\LRO(M,N,i)$}

\begin{algorithm}[H]
\If{$|M|\neq|N|$}{\Return $\bot$}  
$(m_1,m_2\dots m_s)\gets M$\\
$(n_1,n_2\dots n_s)\gets N$\\
$n_i\gets \epsilon$\\
$m_i\gets \epsilon$\\
\eIf{$b=0$}{
$y\getsr \mathsf{AONT.Transform}(m_1,m_2\dots m_s)$\\
}{
$y\getsr \mathsf{AONT.Transform}(n_1,n_2\dots n_s)$\\
}
\Return $y$
\end{algorithm}
}
\end{figure}

Then we say that the indistinguishability adversary $\advA$ has $l$-AONT-IND advantage: 

$$\textbf{Adv}^\text{aont-ind}_\mathsf{AONT}(\advA)=2\cdot\Prob{\gamefont{G}_{\mathsf{AONT}}^\text{ind}(\advA)} - 1$$

\section{Boyko (1999)/ Canetti et. al (2000)}

\begin{figure}[H]
\oneCol{0.5}
{
\underline{$\gamefont{G}_{\mathsf{AONT},l}^\text{leak}(\advA)$}

\begin{algorithm}[H]
$b \getsr \bits$\\
$b' \getsr \advA^{\LRO}$\\
\Return $(b=b')$
\end{algorithm}

\smallskip
\underline{$\LRO(M,N,S)$}

\begin{algorithm}[H]
\If{$|M|\neq|N|$}{\Return $\bot$}  
$(m_1,m_2\dots m_s)\gets M$\\
$(n_1,n_2\dots n_s)\gets N$\\
\eIf{$b=0$}{
$y\getsr \mathsf{AONT.Transform}(m_1,m_2\dots m_s)$\\
}{
$y\getsr \mathsf{AONT.Transform}(n_1,n_2\dots n_s)$\\
}
\eIf{$(|S|\neq|y|)\lor(\mathsf{Hamm}(S)>(|y| - l))$}{\Return $\bot$}{$y\gets y\mathrel{\&} S$}
\Return $y$
\end{algorithm}
}
\end{figure}

\emph{Note that $|M|$ is the length of the string $M$ in bits, $\mathrel{\&}$ is a bitwise AND and $\mathsf{Hamm}(M)$ takes the hamming weight of $M$}

Then we say that the leakage adversary $\advA$ has $l$-AONT-LEAK advantage: 

$$\textbf{Adv}^\text{aont-leak}_{\mathsf{AONT},l}(\advA)=2\cdot\Prob{\gamefont{G}_{\mathsf{AONT},l}^\text{leak}(\advA)} - 1$$

\section{Leakage Resilience Model} 

\begin{figure}[H]
\oneCol{0.5}
{
\underline{$\gamefont{G}_{\mathsf{AONT},m}^\text{lr}(\advA)$}

\begin{algorithm}[H]
$b \getsr \bits$\\
$b' \getsr \advA^{\LRO}$\\
\Return $(b=b')$
\end{algorithm}

\smallskip
\underline{$\LRO(M,N,C)$}

\begin{algorithm}[H]
\If{$|M|\neq|N|$}{\Return $\bot$}  
$(m_1,m_2\dots m_s)\gets M$\\
$(n_1,n_2\dots n_s)\gets N$\\
\eIf{$b=0$}{
$y\getsr \mathsf{AONT.Transform}(m_1,m_2\dots m_s)$\\
}{
$y\getsr \mathsf{AONT.Transform}(n_1,n_2\dots n_s)$\\
}
\eIf{$(C\notin\mathcal{C}_{|y|,(|y| - m)})$}{\Return $\bot$}{\Return $C(y)$}
\end{algorithm}
}
\end{figure}

\emph{Note that $\mathcal{C}_{n,m}$ is the set of boolean circuits taking $n$ inputs and $m$ outputs, expressed in a string in some reasonable encoding. Then, for $C\in \mathcal{C}_{n,m}$, when we run $C(S)$ for some binary string $S$ of length $n$, $C$ will take as input the bits of $S$ and return a $m$ bit long string.}

Then we say that the leakage resilience adversary $\advA$ has $m$-AONT-LR advantage: 

$$\textbf{Adv}^\text{aont-lr}_{\mathsf{AONT},m}(\advA)=2\cdot\Prob{\gamefont{G}_{\mathsf{AONT},m}^\text{lr}(\advA)} - 1$$

\section{Relationship between Notions} 

\subsection{$\mathsf{AONT.bl-AONT-L}\implies\schemefont{AONT-IND}$}

\begin{theorem}
For any $\mathsf{AONT-IND}$ adversary $\advA$, we can construct $\mathsf{AONT.bl-AONT-L}$ adversary $\advB$, running in the same time and making the same number of queries, such that $$\textbf{Adv}^\text{aont-ind}_{\mathsf{AONT}}(\advA)\le\textbf{Adv}^\text{aont-leak}_{\mathsf{AONT},\mathsf{AONT.bl}}(\advB)$$
\end{theorem}

Here is the adversary (the full proof is omitted for now):

\begin{figure}[H]
\oneCol{0.5}
{
\underline{$\advB^\LRO$}

\begin{algorithm}[H]
$b\getsr \advA^{\procfont{SimLR}}$\\
\Return $b$
\end{algorithm}

\underline{$\procfont{SimLR}(M,N,i)$}

\begin{algorithm}[H]
$mask\gets \epsilon$\\
$s\gets \lceil\frac{|M|}{\mathsf{AONT.bl}}\rceil$\\
\For{$j=1,2,\dots s$}
{
\eIf{$j\neq i$}{$mask\gets mask||1^\mathsf{AONT.bl}$}{$mask\gets mask||0^\mathsf{AONT.bl}$}}
\Return $\LRO(M,N,mask)$
\end{algorithm}
}
\end{figure}

\subsection{$l\schemefont{-AONT-L}\implies l\schemefont{-AONT-LR}$}

\begin{theorem}
For any $l-\schemefont{AONT-L}$ adversary $\advA$, we can construct $l-\schemefont{AONT-LR}$ adversary $\advB$, running in the same time and making the same number of queries, such that $$\textbf{Adv}^\text{aont-leak}_{\mathsf{AONT},l}(\advA)\le\textbf{Adv}^\text{aont-lr}_{\mathsf{AONT},l}(\advB)$$
\end{theorem}

Here is the adversary (the full proof is omitted for now):

\begin{figure}[H]
\oneCol{0.5}
{
\underline{$\advB^\LRO$}

\begin{algorithm}[H]
$b\getsr \advA^{\procfont{SimLR}}$\\
\Return $b$
\end{algorithm}

\underline{$\procfont{SimLR}(M,N,mask)$}

\begin{algorithm}[H]
\Return $\LRO(M,N,C_{mask})$
\end{algorithm}

\underline{$C_{mask}(X)$}

\begin{algorithm}[H]
\Return $mask \mathrel{\&} X$
\end{algorithm}
}
\end{figure}

\subsection{$\mathsf{AONT-IND} \not\Rightarrow \mathsf{AONT.bl-AONT-L}$}

Rivest provides a construction of an AONT known as the package transform. It makes use of an arbitrary block cipher, with key of length $\schemefont{AONT.bl}$, $E : \bits^\schemefont{AONT.bl} \times \bits^\schemefont{AONT.bl}\rightarrow \schemefont{AONT.bl}$. 

I modified this scheme slightly to achieve a scheme that is $\mathsf{AONT-IND}$ secure but not $\mathsf{AONT.bl-AONT-L}$ secure. 

\begin{figure}[H]
\twoCols{0.5}{0.5}
{
\underline{$\schemefont{AONT.Transform}(m_1,m_2,\dots m_s)$}

\begin{algorithm}[H]
\If{$\exists i.\len{m_i}\neq\schemefont{AONT.bl}$}{\Return $\bot$}
$K\getsr \bits^\schemefont{AONT.bl}$\\
$K'\getsr \bits^\schemefont{AONT.bl}$\\
$m'_{s+1}\gets K'$\\
\For{$i=1,2\dots s$}
{
$m'_i\gets m_i \oplus E(K',\langle i \rangle_\schemefont{AONT.bl})$\\
$h_i\gets E(K,m'_i\oplus \langle i \rangle_\schemefont{AONT.bl})$\\
$m'_{s+1}\gets m'_{s+1}\oplus h_i$\\
}
$m'_{s+1}\gets E(K,m'_{s+1})$\\
$m'_{s+2}\gets m'_{s+1} \mathrel{\&} 1^{\frac{\mathsf{AONT.bl}}{2}}0^{\frac{\mathsf{AONT.bl}}{2}}$\\
$m'_{s+1}\gets m'_{s+1} \mathrel{\&} 0^{\frac{\mathsf{AONT.bl}}{2}}1^{\frac{\mathsf{AONT.bl}}{2}}$\\
\Return $(m'_1,m'_2\dots m'_s, m'_{s+1}, m'_{s+2}, K)$
\end{algorithm}
}
{
\underline{$\schemefont{AONT.Inverse}(m'_1,m'_2\dots m'_{s'})$}

\begin{algorithm}[H]
\If{$(\exists i.\len{m'_i}\neq\schemefont{AONT.bl})\lor (s' \le 2)$}{\Return $\bot$}
$K\gets m'_{s'}$\\
$K'\gets E^{-1}(K,m'_{s'-1} \oplus m'_{s'-2})$\\
$s\gets s'-3$\\
\For{$(i=1,2,\dots s)$}
{
$h_i\gets E(K,m'_i\oplus i)$\\
$K'\gets K'\oplus h_i$
}
\For{$(i=1,2,\dots s)$}
{
$m_i\gets E(K',i)\oplus m'_i$\\
}
\Return $(m_1,m_2\dots m_{s})$
\end{algorithm}
}
\end{figure} 

Notice that since this construction ensures that there are $\mathsf{AONT.bl}$ bits of ``padding'' in the second and third to last blocks of the pseudo-message, an $\mathsf{AONT.bl}$ leakage adversary can just choose to not receive the padding, and still be able to compute the inverse function in full, since the padding is always zero. On the other hand, suppose that there existed a $\mathsf{AONT-IND}$ adversary against $\mathsf{AONT}$, $\advA$, then we can construct $\advB$, a PRF adversary against block cipher $E$. 


%COMMENTS BELOW 

\begin{comment}
\begin{figure}[H]
\oneCol{0.7}
{

\underline{$\advB$}

\begin{algorithm}[H]
$b\gets \advA^{\procfont{SimLR}}$\\
\Return $b$
\end{algorithm}
\underline{$\procfont{SimLR}(M,N,i)$}
$X\getsr \mathsf{AONT.Transform}(M)$\\
\If{$(X=\bot)$}{\Return $\bot$}
$s'\gets |X|$\\
\eIf{$(i\neq s'-2)\land(i\neq s'-2)$}
{
$X\getsr \LRO(M,N,i)$
\If{$X=\bot$}{\Return $\bot$}
$(m'_1,m'_2\dots m'_{s'})\gets X$ \\
$m'_{s'+1}\gets m'_{s'}$\\
$m'_{s'}\gets m'_{s'-1}\mathrel{\&} 1^{\frac{\mathsf{AONT.bl}}{2}}0^{\frac{\mathsf{AONT.bl}}{2}}$\\
$m'_{s'-1}\gets m'_{s'-1}\mathrel{\&} 0^{\frac{\mathsf{AONT.bl}}{2}}1^{\frac{\mathsf{AONT.bl}}{2}}$\\
\Return $(m'_1,m'_2\dots m'_{s'+1})$
}
{
\eIf{$i=s'-1$}
{

}
{

}
}


\begin{algorithm}[H]
$b\gets \advA^{\procfont{SimLR}}$\\
\Return $b$
\end{algorithm}

}
\end{figure}

Consider the following AONT, $\mathsf{XOR-AONT}$ with some sufficiently large block length and number of messages to prevent exhaustive searches. It is a modified version of the ``package transform'', with some padding. 

\begin{figure}[H]
\twoCols{0.5}{0.5}
{
\underline{$\schemefont{AONT.Transform}(m_1,m_2,\dots m_s)$}

\begin{algorithm}[H]
\If{$\exists i.\len{m_i}\neq\schemefont{AONT.bl}$}{\Return $\bot$}
$K\getsr \bits^\schemefont{AONT.bl}$\\
$K'\getsr \bits^\schemefont{AONT.bl}$\\
$m'_{s+1}\gets K'$\\
\For{$i=1,2\dots s$}
{
$m'_i\gets m_i \oplus E(K',\langle i \rangle_\schemefont{AONT.bl})$\\
$h_i\gets E(K,m'_i\oplus \langle i \rangle_\schemefont{AONT.bl})$\\
$m'_{s+1}\gets m'_{s+1}\oplus h_i$\\
}
$b_1||b_2\dots ||b_\schemefont{AONT.bl}\gets m'_{s+1}$\\
\For{$i=1,2\dots s$}
{
$m'_{s+i}\getsr\bits^\schemefont{AONT.bl}$\\
$m'_{s+i}\gets m'_{s+i} \mathrel{\&} 0^\schemefont{AONT.bl-1}b_i$\\
}
\Return $(m'_1,m'_2\dots m'_{2s-1}, m'_{2s}, K)$
\end{algorithm}
}
{
\underline{$\schemefont{AONT.Inverse}(m'_1,m'_2\dots m'_{s'})$}

\begin{algorithm}[H]
\If{$(\exists i.\len{m'_i}\neq\schemefont{AONT.bl})\lor (s' \le 2)$}{\Return $\bot$}
\For{$i=1,2,\dots s$}
{
$b_i \gets m_{s+i} \mod 2$\\
}
$K'\gets b_1||b_2\dots ||b_\schemefont{AONT.bl}$\\
$K\gets m'_{s'}$\\
$s\gets s'-2$\\
\For{$(i=1,2,\dots s)$}
{
$h_i\gets E(K,m'_i\oplus i)$\\
$K'\gets K'\oplus h_i$
}
\For{$(i=1,2,\dots s)$}
{
$m_i\gets E(K',i)\oplus m'_i$\\
}
\Return $(m_1,m_2\dots m_{s})$
\end{algorithm}
}
\end{figure} 

Then, consider the following $\mathsf{AONT.bl-AONT-L}$ adversary $\advA$ which has $\textbf{Adv}^\text{aont-leak}_{\mathsf{AONT},l}(\advA)=1$, making only 1 query and running as efficiently as the $\schemefont{AONT.Inverse}$ function.

\begin{figure}[H]
\oneCol{0.7}
{

\underline{$\advA$}

\begin{algorithm}[H]
$S\gets 0^{256\cdot\schemefont{AONT.bl}}$\\
\For{$i=1,2,\dots \schemefont{AONT.bl}$}
{
$S\gets S||0^{\schemefont{AONT.bl}-1}1$\\
}
$S\gets S||1^{\schemefont{AONT.bl}}$\\

$M\gets \LRO(0^{256\cdot\schemefont{AONT.bl}},1^{256\cdot\schemefont{AONT.bl}},S)$\\
$X\gets \schemefont{AONT.Inverse}(M)$ \\
\eIf{$M=0^{256\cdot\schemefont{AONT.bl}}$}{\Return 0}{\Return 1}
\end{algorithm}

}
\end{figure}

Notice that the hamming weight of $S$ will be $|S|-\schemefont{AONT.bl}$, and so $\LRO$ will not return $\bot$. In addition, since the bits of the AONT that were not leaked were all ``padding'' bits, the value $X$ is exactly the value that was transformed by the $\LRO$. Therefore, the adversary does not run in time much longer than the inverse function, and has advantage 1. 

Now we show that this is still $\schemefont{AONT-IND}$ secure. We do this by showing that for any $\schemefont{AONT-IND}$ adversary $\advA$ taking time $t$ and making $q$ queries, we have an adversary $\advB$ against the package transform (call this the $\schemefont{Package}$ scheme) such that $$\textbf{Adv}^\text{aont-ind}_\mathsf{AONT}(\advA)\le\textbf{Adv}^\text{aont-ind}_\mathsf{Package}(\advB)$$. Further, if $\advA$ takes time $t$ and makes $q$ queries, then $\advB$ takes time $2t$ and makes $2q$ queries. 

\begin{figure}[H]
\oneCol{0.7}
{

\underline{$\advB$}

\begin{algorithm}[H]
  
\end{algorithm}

}
\end{figure}

\end{comment}
\end{document}








