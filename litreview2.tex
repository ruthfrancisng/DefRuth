% DefCrypt main.tex
% Started 4/2/2017

\documentclass[11pt,twoside]{article}

% ==================================================================
% Subfile Package/Commands
% ==================================================================

\usepackage{subfiles,algorithm2e}

\newcommand{\onlyinsubfile}[1]{#1}
\newcommand{\notinsubfile}[1]{}

\makeatletter
\def\input@path{{./}{../../}}
\makeatother

% ==================================================================
% Crypto Packages
% ==================================================================

\usepackage{defcrypt}
\usepackage{cryptocode}


% ==================================================================
% Document
% ==================================================================

\begin{document}
    \renewcommand{\onlyinsubfile}[1]{}
    \renewcommand{\notinsubfile}[1]{#1}
  
\section{Syntax}

An \emph{All-Or-Nothing-Transform} $\schemefont{AONT}$ specifies two algorithms $(\schemefont{AONT.Transform}, \schemefont{AONT.Inverse})$, and a block length $\schemefont{AONT.bl}$. Then, we can associate with $\mathsf{AONT}$ a domain and range, $\mathsf{AONT}.\mathcal{D}, \mathsf{AONT}.\mathcal{R}\subset \{\bits^\schemefont{AONT.bl}\}^*$(the set of strings having length that is a multiple of $\mathsf{AONT.bl}$). We call the domain the ``message sequences'' and the range the ``pseudo-message sequences''. Then, we have that $\mathsf{AONT.Transform}: \mathsf{AONT}.\mathcal{D}\rightarrow \mathsf{AONT}.\mathcal{R}$, a randomized algorithm, and  $\mathsf{AONT.Inverse}: \mathsf{AONT}.\mathcal{R}\rightarrow \mathsf{AONT}.\mathcal{D}$, a deterministic algorithm. 


\section{Correctness}
The correctness condition for $\schemefont{AONT}$ is $$\Prob{\schemefont{AONT.Inverse}(\schemefont{AONT.Transform}((m_1,m_2\dots m_s))=(m_1,m_2,\dots m_s))} = 1$$ where the probability is taken over all possible message sequences $(m_1,m_2\dots m_s)$ and all possible randomness of the $\schemefont{AONT.Transform}$ function. 

\section{Rivest (1997)}

\begin{figure}[H]
\oneCol{0.5}
{
\underline{$\gamefont{G}_{\mathsf{AONT}}^\text{ind}(\advA)$}

\begin{algorithm}[H]
$b \getsr \bits$\\
$b' \getsr \advA^{\LRO}$\\
\Return $(b=b')$
\end{algorithm}

\smallskip
\underline{$\LRO(M,N,i)$}

\begin{algorithm}[H]
\If{$|M|\neq|N|$}{\Return $\bot$}  
$(m_1,m_2\dots m_s)\gets M$\\
$(n_1,n_2\dots n_s)\gets N$\\
$n_i\gets \epsilon$\\
$m_i\gets \epsilon$\\
\eIf{$b=0$}{
$y\getsr \mathsf{AONT.Transform}(m_1,m_2\dots m_s)$\\
}{
$y\getsr \mathsf{AONT.Transform}(n_1,n_2\dots n_s)$\\
}
\Return $y$
\end{algorithm}
}
\end{figure}

Then we say that the indistinguishability adversary $\advA$ has $l$-AONT-IND advantage: 

$$\textbf{Adv}^\text{aont-ind}_\mathsf{AONT}(\advA)=2\cdot\Prob{\gamefont{G}_{\mathsf{AONT}}^\text{ind}(\advA)} - 1$$

\section{Boyko (1999)/ Canetti et. al (2000)}

\begin{figure}[H]
\oneCol{0.5}
{
\underline{$\gamefont{G}_{\mathsf{AONT},l}^\text{leak}(\advA)$}

\begin{algorithm}[H]
$b \getsr \bits$\\
$b' \getsr \advA^{\LRO}$\\
\Return $(b=b')$
\end{algorithm}

\smallskip
\underline{$\LRO(M,N,S)$}

\begin{algorithm}[H]
\If{$|M|\neq|N|$}{\Return $\bot$}  
$(m_1,m_2\dots m_s)\gets M$\\
$(n_1,n_2\dots n_s)\gets N$\\
\eIf{$b=0$}{
$y\getsr \mathsf{AONT.Transform}(m_1,m_2\dots m_s)$\\
}{
$y\getsr \mathsf{AONT.Transform}(n_1,n_2\dots n_s)$\\
}
\eIf{$(|S|\neq|y|)\lor(\mathsf{Hamm}(S)>(|y| - l))$}{\Return $\bot$}{$y\gets y\mathrel{\&} S$}
\Return $y$
\end{algorithm}
}
\end{figure}

\emph{Note that $|M|$ is the length of the string $M$ in bits, $\mathrel{\&}$ is a bitwise AND and $\mathsf{Hamm}(M)$ takes the hamming weight of $M$}

Then we say that the leakage adversary $\advA$ has $l$-AONT-LEAK advantage: 

$$\textbf{Adv}^\text{aont-leak}_{\mathsf{AONT},l}(\advA)=2\cdot\Prob{\gamefont{G}_{\mathsf{AONT},l}^\text{leak}(\advA)} - 1$$

\section{Leakage Resilience Model} 

\begin{figure}[H]
\oneCol{0.5}
{
\underline{$\gamefont{G}_{\mathsf{AONT},m}^\text{lr}(\advA)$}

\begin{algorithm}[H]
$b \getsr \bits$\\
$b' \getsr \advA^{\LRO}$\\
\Return $(b=b')$
\end{algorithm}

\smallskip
\underline{$\LRO(M,N,C)$}

\begin{algorithm}[H]
\If{$|M|\neq|N|$}{\Return $\bot$}  
$(m_1,m_2\dots m_s)\gets M$\\
$(n_1,n_2\dots n_s)\gets N$\\
\eIf{$b=0$}{
$y\getsr \mathsf{AONT.Transform}(m_1,m_2\dots m_s)$\\
}{
$y\getsr \mathsf{AONT.Transform}(n_1,n_2\dots n_s)$\\
}
\eIf{$(C\notin\mathcal{C}_{|y|,(|y| - m)})$}{\Return $\bot$}{\Return $C(y)$}
\end{algorithm}
}
\end{figure}

\emph{Note that $\mathcal{C}_{n,m}$ is the set of boolean circuits taking $n$ inputs and $m$ outputs, expressed in a string in some reasonable encoding. Then, for $C\in \mathcal{C}_{n,m}$, when we run $C(S)$ for some binary string $S$ of length $n$, $C$ will take as input the bits of $S$ and return a $m$ bit long string.}

Then we say that the leakage resilience adversary $\advA$ has $m$-AONT-LR advantage: 

$$\textbf{Adv}^\text{aont-lr}_{\mathsf{AONT},m}(\advA)=2\cdot\Prob{\gamefont{G}_{\mathsf{AONT},m}^\text{lr}(\advA)} - 1$$

\section{Relationship between Notions} 

\subsection{$\mathsf{AONT.bl-AONT-L}\implies\schemefont{AONT-IND}$}

\begin{theorem}
For any $\mathsf{AONT-IND}$ adversary $\advA$, we can construct $\mathsf{AONT.bl-AONT-L}$ adversary $\advB$, running in the same time and making the same number of queries, such that $$\textbf{Adv}^\text{aont-ind}_{\mathsf{AONT}}(\advA)\le\textbf{Adv}^\text{aont-leak}_{\mathsf{AONT},\mathsf{AONT.bl}}(\advB)$$
\end{theorem}

Here is the adversary (the full proof is omitted for now):

\begin{figure}[H]
\oneCol{0.5}
{
\underline{$\advB^\LRO$}

\begin{algorithm}[H]
$b\getsr \advA^{\procfont{SimLR}}$\\
\Return $b$
\end{algorithm}

\underline{$\procfont{SimLR}(M,N,i)$}

\begin{algorithm}[H]
$mask\gets \epsilon$\\
$s\gets \lceil\frac{|M|}{\mathsf{AONT.bl}}\rceil$\\
\For{$j=1,2,\dots s$}
{
\eIf{$j\neq i$}{$mask\gets mask||1^\mathsf{AONT.bl}$}{$mask\gets mask||0^\mathsf{AONT.bl}$}}
\Return $\LRO(M,N,mask)$
\end{algorithm}
}
\end{figure}

\subsection{$l\schemefont{-AONT-L}\implies l\schemefont{-AONT-LR}$}

\begin{theorem}
For any $l-\schemefont{AONT-L}$ adversary $\advA$, we can construct $l-\schemefont{AONT-LR}$ adversary $\advB$, running in the same time and making the same number of queries, such that $$\textbf{Adv}^\text{aont-leak}_{\mathsf{AONT},l}(\advA)\le\textbf{Adv}^\text{aont-lr}_{\mathsf{AONT},l}(\advB)$$
\end{theorem}

Here is the adversary (the full proof is omitted for now):

\begin{figure}[H]
\oneCol{0.5}
{
\underline{$\advB^\LRO$}

\begin{algorithm}[H]
$b\getsr \advA^{\procfont{SimLR}}$\\
\Return $b$
\end{algorithm}

\underline{$\procfont{SimLR}(M,N,mask)$}

\begin{algorithm}[H]
\Return $\LRO(M,N,C_{mask})$
\end{algorithm}

\underline{$C_{mask}(X)$}

\begin{algorithm}[H]
\Return $mask \mathrel{\&} X$
\end{algorithm}
}
\end{figure}

\subsection{$\mathsf{AONT.bl-AONT-L}\not\Rightarrow \mathsf{AONT.bl-AONT-LR}$}

Consider the following AONT scheme, $\mathsf{Checksum}$, which is defined for all choices of $\mathsf{Checksum.bl}$. It has $\mathsf{Checksum}.\mathcal{D}=\bits^{\mathsf{Checksum.bl}}$ and $\mathsf{Checksum}.\mathcal{R}=\bits^{\mathsf{Checksum.bl}^2}$:

\begin{figure}[H]
\twoCols{0.5}{0.5}
{
\underline{$\schemefont{Checksum.Transform}(m)$}
\begin{algorithm}[H]
$m'_\mathsf{Checksum.bl}\gets m$\\
\For{$i=1,2,\dots \mathsf{Checksum.bl}-1$}
{
$m'_i\getsr \bits^\mathsf{Checksum.bl}$\\
$m'_\mathsf{Checksum.bl}\gets m'_i \oplus m'_\mathsf{Checksum.bl}$\\
}
\Return $(m'_1,m'_2\dots m'_\mathsf{Checksum.bl})$
\end{algorithm}
}
{
\underline{$\schemefont{Checksum.Inverse}(m'_1,m'_2\dots m'_\mathsf{Checksum.bl})$}

\begin{algorithm}[H]
$m\gets m'_\mathsf{Checksum.bl}$\\
\For{$i=1,2,\dots \mathsf{Checksum.bl}-1$}
{
$m\gets m'_i \oplus m$\\
}
\Return $m$ 
\end{algorithm}
}
\end{figure} 

First, let's show that $\mathsf{Checksum}$ is $\mathsf{Checksum.bl-AONT-L}$ secure. 

Next, we can provide a $\mathsf{Checksum.bl-AONT-LR}$ adversary $\advA$. 

WAIT THIS IS AONT.IND nor AONT-L because we can just take all the first bits and check. Maybe do something with permutations? 

\subsection{$\mathsf{AONT-IND} \not\Rightarrow \mathsf{AONT.bl-AONT-L}$}

Rivest provides a construction of an AONT known as the package transform. It makes use of an arbitrary block cipher, with key of length $\schemefont{AONT.bl}$, $E : \bits^\schemefont{AONT.bl} \times \bits^\schemefont{AONT.bl}\rightarrow \schemefont{AONT.bl}$. 

I modified this scheme slightly to achieve a scheme that is $\mathsf{AONT-IND}$ secure but not $\mathsf{AONT.bl-AONT-L}$ secure. 

\begin{figure}[H]
\twoCols{0.5}{0.5}
{
\underline{$\schemefont{AONT.Transform}(m_1,m_2,\dots m_s)$}

\begin{algorithm}[H]
\If{$\exists i.\len{m_i}\neq\schemefont{AONT.bl}$}{\Return $\bot$}
$K\getsr \bits^\schemefont{AONT.bl}$\\
$K'\getsr \bits^\schemefont{AONT.bl}$\\
$m'_{s+1}\gets K'$\\
\For{$i=1,2\dots s$}
{
$m'_i\gets m_i \oplus E(K',\langle i \rangle_\schemefont{AONT.bl})$\\
$h_i\gets E(K,m'_i\oplus \langle i \rangle_\schemefont{AONT.bl})$\\
$m'_{s+1}\gets m'_{s+1}\oplus h_i$\\
}
$m'_{s+1}\gets E(K,m'_{s+1})$\\
$m'_{s+2}\gets m'_{s+1} \mathrel{\&} 1^{\frac{\mathsf{AONT.bl}}{2}}0^{\frac{\mathsf{AONT.bl}}{2}}$\\
$m'_{s+1}\gets m'_{s+1} \mathrel{\&} 0^{\frac{\mathsf{AONT.bl}}{2}}1^{\frac{\mathsf{AONT.bl}}{2}}$\\
\Return $(m'_1,m'_2\dots m'_s, m'_{s+1}, m'_{s+2}, K)$
\end{algorithm}
}
{
\underline{$\schemefont{AONT.Inverse}(m'_1,m'_2\dots m'_{s'})$}

\begin{algorithm}[H]
\If{$(\exists i.\len{m'_i}\neq\schemefont{AONT.bl})\lor (s' \le 2)$}{\Return $\bot$}
$K\gets m'_{s'}$\\
$K'\gets E^{-1}(K,m'_{s'-1} \oplus m'_{s'-2})$\\
$s\gets s'-3$\\
\For{$(i=1,2,\dots s)$}
{
$h_i\gets E(K,m'_i\oplus i)$\\
$K'\gets K'\oplus h_i$
}
\For{$(i=1,2,\dots s)$}
{
$m_i\gets E(K',i)\oplus m'_i$\\
}
\Return $(m_1,m_2\dots m_{s})$
\end{algorithm}
}
\end{figure} 

Notice that since this construction ensures that there are $\mathsf{AONT.bl}$ bits of ``padding'' in the second and third to last blocks of the pseudo-message, an $\mathsf{AONT.bl}$ leakage adversary can just choose to not receive the padding, and still be able to compute the inverse function in full, since the padding is always zero. On the other hand, suppose that there existed a $\mathsf{AONT-IND}$ adversary against $\mathsf{AONT}$, $\advA$, then we can construct $\advB$, a PRF adversary against block cipher $E$. ACTUALLY, BOYKO'S PAPER SHOULD HAVE A VALID PROOF. 



\end{document}








